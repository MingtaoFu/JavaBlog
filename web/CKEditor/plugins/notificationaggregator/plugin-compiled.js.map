{"version":3,"sources":["plugin.js"],"names":[],"mappings":"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","file":"plugin-compiled.js","sourcesContent":["/**\n * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or http://ckeditor.com/license\n */\n\n/**\n * @fileOverview The \"Notification Aggregator\" plugin.\n *\n */\n\n( function() {\n\t'use strict';\n\n\tCKEDITOR.plugins.add( 'notificationaggregator', {\n\t\trequires: 'notification'\n\t} );\n\n\t/**\n\t * An aggregator of multiple tasks (progresses) which should be displayed using one\n\t * {@link CKEDITOR.plugins.notification notification}.\n\t *\n\t * Once all the tasks are done, it means that the whole process is finished and the {@link #finished}\n\t * event will be fired.\n\t *\n\t * New tasks can be created after the previous set of tasks is finished. This will continue the process and\n\t * fire the {@link #finished} event again when it is done.\n\t *\n\t * Simple usage example:\n\t *\n\t *\t\t// Declare one aggregator that will be used for all tasks.\n\t *\t\tvar aggregator;\n\t *\n\t *\t\t// ...\n\t *\n\t *\t\t// Create a new aggregator if the previous one finished all tasks.\n\t *\t\tif ( !aggregator || aggregator.isFinished() ) {\n\t *\t\t\t// Create a new notification aggregator instance.\n\t *\t\t\taggregator = new CKEDITOR.plugins.notificationAggregator( editor, 'Loading process, step {current} of {max}...' );\n\t *\n\t *\t\t\t// Change the notification type to 'success' on finish.\n\t *\t\t\taggregator.on( 'finished', function() {\n\t *\t\t\t\taggregator.notification.update( { message: 'Done', type: 'success' } );\n\t *\t\t\t} );\n\t *\t\t}\n\t *\n\t *\t\t// Create 3 tasks.\n\t *\t\tvar taskA = aggregator.createTask(),\n\t *\t\t\ttaskB = aggregator.createTask(),\n\t *\t\t\ttaskC = aggregator.createTask();\n\t *\n\t *\t\t// At this point the notification contains a message: \"Loading process, step 0 of 3...\".\n\t *\n\t *\t\t// Let's close the first one immediately.\n\t *\t\ttaskA.done(); // \"Loading process, step 1 of 3...\".\n\t *\n\t *\t\t// One second later the message will be: \"Loading process, step 2 of 3...\".\n\t *\t\tsetTimeout( function() {\n\t *\t\t\ttaskB.done();\n\t *\t\t}, 1000 );\n\t *\n\t *\t\t// Two seconds after the previous message the last task will be completed, meaning that\n\t *\t\t// the notification will be closed.\n\t *\t\tsetTimeout( function() {\n\t *\t\t\ttaskC.done();\n\t *\t\t}, 3000 );\n\t *\n\t * @since 4.5\n\t * @class CKEDITOR.plugins.notificationAggregator\n\t * @mixins CKEDITOR.event\n\t * @constructor Creates a notification aggregator instance.\n\t * @param {CKEDITOR.editor} editor\n\t * @param {String} message The template for the message to be displayed in the notification. The template can use\n\t * the following variables:\n\t *\n\t * * `{current}` &ndash; The number of completed tasks.\n\t * * `{max}` &ndash; The number of tasks.\n\t * * `{percentage}` &ndash; The progress (number 0-100).\n\t *\n\t * @param {String/null} [singularMessage=null] An optional template for the message to be displayed in the notification\n\t * when there is only one task remaining.  This template can use the same variables as the `message` template.\n\t * If `null`, then the `message` template will be used.\n\t */\n\tfunction Aggregator( editor, message, singularMessage ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @property {CKEDITOR.editor} editor\n\t\t */\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * Notification created by the aggregator.\n\t\t *\n\t\t * The notification object is modified as aggregator tasks are being closed.\n\t\t *\n\t\t * @readonly\n\t\t * @property {CKEDITOR.plugins.notification/null}\n\t\t */\n\t\tthis.notification = null;\n\n\t\t/**\n\t\t * A template for the notification message.\n\t\t *\n\t\t * The template can use the following variables:\n\t\t *\n\t\t * * `{current}` &ndash; The number of completed tasks.\n\t\t * * `{max}` &ndash; The number of tasks.\n\t\t * * `{percentage}` &ndash; The progress (number 0-100).\n\t\t *\n\t\t * @private\n\t\t * @property {CKEDITOR.template}\n\t\t */\n\t\tthis._message = new CKEDITOR.template( message );\n\n\t\t/**\n\t\t * A template for the notification message used when only one task is loading.\n\t\t *\n\t\t * Sometimes there might be a need to specify a special message when there\n\t\t * is only one task loading, and to display standard messages in other cases.\n\t\t *\n\t\t * For example, you might want to show a message \"Translating a widget\" rather than\n\t\t * \"Translating widgets (1 of 1)\", but still you would want to have a message\n\t\t * \"Translating widgets (2 of 3)\" if more widgets are being translated at the same\n\t\t * time.\n\t\t *\n\t\t * Template variables are the same as in {@link #_message}.\n\t\t *\n\t\t * @private\n\t\t * @property {CKEDITOR.template/null}\n\t\t */\n\t\tthis._singularMessage = singularMessage ? new CKEDITOR.template( singularMessage ) : null;\n\n\t\t// Set the _tasks, _totalWeights, _doneWeights, _doneTasks properties.\n\t\tthis._tasks = [];\n\t\tthis._totalWeights = 0;\n\t\tthis._doneWeights = 0;\n\t\tthis._doneTasks = 0;\n\n\t\t/**\n\t\t * Array of tasks tracked by the aggregator.\n\t\t *\n\t\t * @private\n\t\t * @property {CKEDITOR.plugins.notificationAggregator.task[]} _tasks\n\t\t */\n\n\t\t/**\n\t\t * Stores the sum of declared weights for all contained tasks.\n\t\t *\n\t\t * @private\n\t\t * @property {Number} _totalWeights\n\t\t */\n\n\t\t/**\n\t\t * Stores the sum of done weights for all contained tasks.\n\t\t *\n\t\t * @private\n\t\t * @property {Number} _doneWeights\n\t\t */\n\n\t\t/**\n\t\t * Stores the count of tasks done.\n\t\t *\n\t\t * @private\n\t\t * @property {Number} _doneTasks\n\t\t */\n\t}\n\n\tAggregator.prototype = {\n\t\t/**\n\t\t * Creates a new task that can be updated to indicate the progress.\n\t\t *\n\t\t * @param [options] Options object for the task creation.\n\t\t * @param [options.weight] For more information about weight, see the\n\t\t * {@link CKEDITOR.plugins.notificationAggregator.task} overview.\n\t\t * @returns {CKEDITOR.plugins.notificationAggregator.task} An object that represents the task state, and allows\n\t\t * for its manipulation.\n\t\t */\n\t\tcreateTask: function( options ) {\n\t\t\toptions = options || {};\n\n\t\t\tvar initialTask = !this.notification,\n\t\t\t\ttask;\n\n\t\t\tif ( initialTask ) {\n\t\t\t\t// It's a first call.\n\t\t\t\tthis.notification = this._createNotification();\n\t\t\t}\n\n\t\t\ttask = this._addTask( options );\n\n\t\t\ttask.on( 'updated', this._onTaskUpdate, this );\n\t\t\ttask.on( 'done', this._onTaskDone, this );\n\t\t\ttask.on( 'canceled', function() {\n\t\t\t\tthis._removeTask( task );\n\t\t\t}, this );\n\n\t\t\t// Update the aggregator.\n\t\t\tthis.update();\n\n\t\t\tif ( initialTask ) {\n\t\t\t\tthis.notification.show();\n\t\t\t}\n\n\t\t\treturn task;\n\t\t},\n\n\t\t/**\n\t\t * Triggers an update on the aggregator, meaning that its UI will be refreshed.\n\t\t *\n\t\t * When all the tasks are done, the {@link #finished} event is fired.\n\t\t */\n\t\tupdate: function() {\n\t\t\tthis._updateNotification();\n\n\t\t\tif ( this.isFinished() ) {\n\t\t\t\tthis.fire( 'finished' );\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Returns a number from `0` to `1` representing the done weights to total weights ratio\n\t\t * (showing how many of the tasks are done).\n\t\t *\n\t\t * Note: For an empty aggregator (without any tasks created) it will return `1`.\n\t\t *\n\t\t * @returns {Number} Returns the percentage of tasks done as a number ranging from `0` to `1`.\n\t\t */\n\t\tgetPercentage: function() {\n\t\t\t// In case there are no weights at all we'll return 1.\n\t\t\tif ( this.getTaskCount() === 0 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn this._doneWeights / this._totalWeights;\n\t\t},\n\n\t\t/**\n\t\t * @returns {Boolean} Returns `true` if all notification tasks are done\n\t\t * (or there are no tasks at all).\n\t\t */\n\t\tisFinished: function() {\n\t\t\treturn this.getDoneTaskCount() === this.getTaskCount();\n\t\t},\n\n\t\t/**\n\t\t * @returns {Number} Returns a total tasks count.\n\t\t */\n\t\tgetTaskCount: function() {\n\t\t\treturn this._tasks.length;\n\t\t},\n\n\t\t/**\n\t\t * @returns {Number} Returns the number of tasks done.\n\t\t */\n\t\tgetDoneTaskCount: function() {\n\t\t\treturn this._doneTasks;\n\t\t},\n\n\t\t/**\n\t\t * Updates the notification content.\n\t\t *\n\t\t * @private\n\t\t */\n\t\t_updateNotification: function() {\n\t\t\tthis.notification.update( {\n\t\t\t\tmessage: this._getNotificationMessage(),\n\t\t\t\tprogress: this.getPercentage()\n\t\t\t} );\n\t\t},\n\n\t\t/**\n\t\t * Returns a message used in the notification.\n\t\t *\n\t\t * @private\n\t\t * @returns {String}\n\t\t */\n\t\t_getNotificationMessage: function() {\n\t\t\tvar tasksCount = this.getTaskCount(),\n\t\t\t\tdoneTasks = this.getDoneTaskCount(),\n\t\t\t\ttemplateParams = {\n\t\t\t\t\tcurrent: doneTasks,\n\t\t\t\t\tmax: tasksCount,\n\t\t\t\t\tpercentage: Math.round( this.getPercentage() * 100 )\n\t\t\t\t},\n\t\t\t\ttemplate;\n\n\t\t\t// If there's only one remaining task and we have a singular message, we should use it.\n\t\t\tif ( tasksCount == 1 && this._singularMessage ) {\n\t\t\t\ttemplate = this._singularMessage;\n\t\t\t} else {\n\t\t\t\ttemplate = this._message;\n\t\t\t}\n\n\t\t\treturn template.output( templateParams );\n\t\t},\n\n\t\t/**\n\t\t * Creates a notification object.\n\t\t *\n\t\t * @private\n\t\t * @returns {CKEDITOR.plugins.notification}\n\t\t */\n\t\t_createNotification: function() {\n\t\t\treturn new CKEDITOR.plugins.notification( this.editor, {\n\t\t\t\ttype: 'progress'\n\t\t\t} );\n\t\t},\n\n\t\t/**\n\t\t * Creates a {@link CKEDITOR.plugins.notificationAggregator.task} instance based\n\t\t * on `options`, and adds it to the task list.\n\t\t *\n\t\t * @private\n\t\t * @param options Options object coming from the {@link #createTask} method.\n\t\t * @returns {CKEDITOR.plugins.notificationAggregator.task}\n\t\t */\n\t\t_addTask: function( options ) {\n\t\t\tvar task = new Task( options.weight );\n\t\t\tthis._tasks.push( task );\n\t\t\tthis._totalWeights += task._weight;\n\t\t\treturn task;\n\t\t},\n\n\t\t/**\n\t\t * Removes a given task from the {@link #_tasks} array and updates the UI.\n\t\t *\n\t\t * @private\n\t\t * @param {CKEDITOR.plugins.notificationAggregator.task} task Task to be removed.\n\t\t */\n\t\t_removeTask: function( task ) {\n\t\t\tvar index = CKEDITOR.tools.indexOf( this._tasks, task );\n\n\t\t\tif ( index !== -1 ) {\n\t\t\t\t// If task was already updated with some weight, we need to remove\n\t\t\t\t// this weight from our cache.\n\t\t\t\tif ( task._doneWeight ) {\n\t\t\t\t\tthis._doneWeights -= task._doneWeight;\n\t\t\t\t}\n\n\t\t\t\tthis._totalWeights -= task._weight;\n\n\t\t\t\tthis._tasks.splice( index, 1 );\n\t\t\t\t// And we also should inform the UI about this change.\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * A listener called on the {@link CKEDITOR.plugins.notificationAggregator.task#update} event.\n\t\t *\n\t\t * @private\n\t\t * @param {CKEDITOR.eventInfo} evt Event object of the {@link CKEDITOR.plugins.notificationAggregator.task#update} event.\n\t\t */\n\t\t_onTaskUpdate: function( evt ) {\n\t\t\tthis._doneWeights += evt.data;\n\t\t\tthis.update();\n\t\t},\n\n\t\t/**\n\t\t * A listener called on the {@link CKEDITOR.plugins.notificationAggregator.task#event-done} event.\n\t\t *\n\t\t * @private\n\t\t * @param {CKEDITOR.eventInfo} evt Event object of the {@link CKEDITOR.plugins.notificationAggregator.task#event-done} event.\n\t\t */\n\t\t_onTaskDone: function() {\n\t\t\tthis._doneTasks += 1;\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\tCKEDITOR.event.implementOn( Aggregator.prototype );\n\n\t/**\n\t * # Overview\n\t *\n\t * This type represents a single task in the aggregator, and exposes methods to manipulate its state.\n\t *\n\t * ## Weights\n\t *\n\t * Task progess is based on its **weight**.\n\t *\n\t * As you create a task, you need to declare its weight. As you want the update to inform about the\n\t * progress, you will need to {@link #update} the task, telling how much of this weight is done.\n\t *\n\t * For example, if you declare that your task has a weight that equals `50` and then call `update` with `10`,\n\t * you will end up with telling that the task is done in 20%.\n\t *\n\t * ### Example Usage of Weights\n\t *\n\t * Let us say that you use tasks for file uploading.\n\t *\n\t * A single task is associated with a single file upload. You can use the file size in bytes as a weight,\n\t * and then as the file upload progresses you just call the `update` method with the number of bytes actually\n\t * downloaded.\n\t *\n\t * @since 4.5\n\t * @class CKEDITOR.plugins.notificationAggregator.task\n\t * @mixins CKEDITOR.event\n\t * @constructor Creates a task instance for notification aggregator.\n\t * @param {Number} [weight=1]\n\t */\n\tfunction Task( weight ) {\n\t\t/**\n\t\t * Total weight of the task.\n\t\t *\n\t\t * @private\n\t\t * @property {Number}\n\t\t */\n\t\tthis._weight = weight || 1;\n\n\t\t/**\n\t\t * Done weight of the task.\n\t\t *\n\t\t * @private\n\t\t * @property {Number}\n\t\t */\n\t\tthis._doneWeight = 0;\n\n\t\t/**\n\t\t * Indicates when the task is canceled.\n\t\t *\n\t\t * @private\n\t\t * @property {Boolean}\n\t\t */\n\t\tthis._isCanceled = false;\n\t}\n\n\tTask.prototype = {\n\t\t/**\n\t\t * Marks the task as done.\n\t\t */\n\t\tdone: function() {\n\t\t\tthis.update( this._weight );\n\t\t},\n\n\t\t/**\n\t\t * Updates the done weight of a task.\n\t\t *\n\t\t * @param {Number} weight Number indicating how much of the total task {@link #_weight} is done.\n\t\t */\n\t\tupdate: function( weight ) {\n\t\t\t// If task is already done or canceled there is no need to update it, and we don't expect\n\t\t\t// progress to be reversed.\n\t\t\tif ( this.isDone() || this.isCanceled() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Note that newWeight can't be higher than _doneWeight.\n\t\t\tvar newWeight = Math.min( this._weight, weight ),\n\t\t\t\tweightChange = newWeight - this._doneWeight;\n\n\t\t\tthis._doneWeight = newWeight;\n\n\t\t\t// Fire updated event even if task is done in order to correctly trigger updating the\n\t\t\t// notification's message. If we wouldn't do this, then the last weight change would be ignored.\n\t\t\tthis.fire( 'updated', weightChange );\n\n\t\t\tif ( this.isDone() ) {\n\t\t\t\tthis.fire( 'done' );\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Cancels the task (the task will be removed from the aggregator).\n\t\t */\n\t\tcancel: function() {\n\t\t\t// If task is already done or canceled.\n\t\t\tif ( this.isDone() || this.isCanceled() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Mark task as canceled.\n\t\t\tthis._isCanceled = true;\n\n\t\t\t// We'll fire cancel event it's up to aggregator to listen for this event,\n\t\t\t// and remove the task.\n\t\t\tthis.fire( 'canceled' );\n\t\t},\n\n\t\t/**\n\t\t * Checks if the task is done.\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisDone: function() {\n\t\t\treturn this._weight === this._doneWeight;\n\t\t},\n\n\t\t/**\n\t\t * Checks if the task is canceled.\n\t\t *\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisCanceled: function() {\n\t\t\treturn this._isCanceled;\n\t\t}\n\t};\n\n\tCKEDITOR.event.implementOn( Task.prototype );\n\n\t/**\n\t * Fired when all tasks are done. When this event occurs, the notification may change its type to `success` or be hidden:\n\t *\n\t *\t\taggregator.on( 'finished', function() {\n\t *\t\t\tif ( aggregator.getTaskCount() == 0 ) {\n\t *\t\t\t\taggregator.notification.hide();\n\t *\t\t\t} else {\n\t *\t\t\t\taggregator.notification.update( { message: 'Done', type: 'success' } );\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * @event finished\n\t * @member CKEDITOR.plugins.notificationAggregator\n\t */\n\n\t/**\n\t * Fired upon each weight update of the task.\n\t *\n\t *\t\tvar myTask = new Task( 100 );\n\t *\t\tmyTask.update( 30 );\n\t *\t\t// Fires updated event with evt.data = 30.\n\t *\t\tmyTask.update( 40 );\n\t *\t\t// Fires updated event with evt.data = 10.\n\t *\t\tmyTask.update( 20 );\n\t *\t\t// Fires updated event with evt.data = -20.\n\t *\n\t * @event updated\n\t * @param {Number} data The difference between the new weight and the previous one.\n\t * @member CKEDITOR.plugins.notificationAggregator.task\n\t */\n\n\t/**\n\t * Fired when the task is done.\n\t *\n\t * @event done\n\t * @member CKEDITOR.plugins.notificationAggregator.task\n\t */\n\n\t/**\n\t * Fired when the task is canceled.\n\t *\n\t * @event canceled\n\t * @member CKEDITOR.plugins.notificationAggregator.task\n\t */\n\n\t// Expose Aggregator type.\n\tCKEDITOR.plugins.notificationAggregator = Aggregator;\n\tCKEDITOR.plugins.notificationAggregator.task = Task;\n} )();\n"]}